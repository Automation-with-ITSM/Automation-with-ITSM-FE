name: Update issue from Jira

on:
  repository_dispatch:
    types: [jira-issue-updated]

permissions:
  contents: read
  issues: write

jobs:
  update-issue:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # (ì„ íƒ) ë“¤ì–´ì˜¨ payloadë¥¼ í•œ ë²ˆ í™•ì¸í•˜ê³  ì‹¶ì„ ë•Œ ì¼ ë‹¤
      - name: Debug payload (optional)
        run: echo "${{ toJson(github.event.client_payload) }}"

      - name: Render via template and safe patch (with Jira fetch fallback)
        uses: actions/github-script@v7
        env:
          # ğŸ” ë ˆí¬/Org Secretsë¡œ ì¶”ê°€í•´ë‘” ê°’ ì‚¬ìš©
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Node20ì€ global fetchê°€ ì¡´ì¬. ì—†ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ require fallback
            const fetch = global.fetch || ((...args) => import('node-fetch').then(({default: f}) => f(...args)));

            const p   = context.payload.client_payload || {};
            const esc = (s) => (s ?? '').toString();
            const nz  = (s, f='') => { const v = esc(s).trim(); return v ? v : f; };
            const has = (s) => !!esc(s).trim();

            // urlEncoded(%)ì´ë©´ ë³µì› (+ â†’ ê³µë°±)
            const decodeMaybe = (s) => {
              const str = esc(s);
              try {
                const decoded = /%[0-9A-Fa-f]{2}/.test(str) ? decodeURIComponent(str) : str;
                return decoded.replace(/\+/g, ' ');
              } catch { return str; }
            };

            // âœ… Jiraì—ì„œ rendered description(HTML) ë³´ê°•
            async function fetchJiraDescriptionHTML(issueKey) {
              const base = (process.env.JIRA_BASE_URL || process.env.JIRA_BASE || '').replace(/\/+$/,'');
              if (!base || !issueKey) return '';
              const url = `${base}/rest/api/3/issue/${encodeURIComponent(issueKey)}?expand=renderedFields&fields=description`;
              const resp = await fetch(url, {
                headers: {
                  'Accept': 'application/json',
                  'Authorization': 'Basic ' + Buffer.from(`${process.env.JIRA_USER_EMAIL}:${process.env.JIRA_API_TOKEN}`).toString('base64')
                }
              });
              if (!resp.ok) {
                core.info(`Jira GET failed: ${resp.status} ${await resp.text()}`);
                return '';
              }
              const data = await resp.json();
              return (data.renderedFields && data.renderedFields.description) ? data.renderedFields.description : '';
            }

            // ğŸ”§ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ê¹ƒí—ˆë¸Œ ì²´í¬ë°•ìŠ¤ë¡œ ì •ê·œí™”
            function normalizeChecklist(input) {
              const raw = decodeMaybe(input);
              if (!has(raw)) return '';
              const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              return lines.map(line => {
                // ì´ë¯¸ - [ ] í˜•íƒœë©´ ìœ ì§€, ì•„ë‹ˆë¼ë©´ ë³€í™˜
                if (/^- \[.\] /.test(line)) return line;
                // Jiraì˜ [] ì ‘ë‘ ë“± ë‹¤ì–‘í•œ íŒ¨í„´ì„ - [ ] ë¡œ ë§¤í•‘
                if (/^\[\s?\]\s*/.test(line)) return line.replace(/^\[\s?\]\s*/, '- [ ] ');
                if (/^[\*\-]\s+/.test(line))   return line.replace(/^[\*\-]\s+/, '- [ ] ');
                return `- [ ] ${line}`;
              }).join('\n');
            }

            // 0) í•„ìˆ˜ê°’: GH ì´ìŠˆë²ˆí˜¸
            const issue_number = Number(p.issue_number);
            if (!issue_number) { core.setFailed('Missing issue_number in payload'); return; }

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // 1) í˜„ì¬ GH ì´ìŠˆ ì½ê¸°(ë¹ˆê°’ ë®ì–´ì“°ê¸° ë°©ì§€)
            const cur = await github.rest.issues.get({ owner, repo, issue_number });
            const curTitle  = cur.data.title || '';
            const curBody   = cur.data.body  || '';
            const curLabels = (cur.data.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);

            // 2) kind ì •ê·œí™” (í•œê¸€/ì˜ë¬¸)
            const rawKind = esc(p.kind).toLowerCase();
            const isStory = /^(story|ìŠ¤í† ë¦¬)/.test(rawKind);
            const isBug   = /^(bug|ë²„ê·¸)/.test(rawKind);
            const kind    = isStory ? 'story' : (isBug ? 'bug' : 'task');

            // 3) í…œí”Œë¦¿ ì„ íƒ (ì—…ë°ì´íŠ¸ë„ ìƒì„±ê³¼ ë™ì¼ í…œí”Œë¦¿ ì‚¬ìš©)
            const mapping = {
              story: '.github/ISSUE_TEMPLATE/automation-story.md',
              bug:   '.github/ISSUE_TEMPLATE/automation-bug.md',
              task:  '.github/ISSUE_TEMPLATE/automation-task.md'
            };
            const file = mapping[kind] || mapping.task;
            const templatePath = path.join(process.cwd(), file);
            const hasTemplate = fs.existsSync(templatePath);
            const tpl = hasTemplate ? fs.readFileSync(templatePath, 'utf8') : '';

            // 4) ê°’ ì¤€ë¹„ + Jira ë³´ê°•
            const key         = esc(p.key);
            const urlLink     = esc(p.url);
            const summary     = esc(p.summary);
            let   description = esc(p.description);   // payloadê°€ ë¹„ë©´ Jira APIë¡œ ë³´ê°•
            const priority    = esc(p.priority);
            const duedate     = nz(p.duedate, 'ë¯¸ì •');
            const checklistMD = normalizeChecklist(p.checklist);

            if (!description.trim() && key) {
              const html = await fetchJiraDescriptionHTML(key);
              if (has(html)) description = html; // HTML ê·¸ëŒ€ë¡œ ì‚¬ìš©(ê¹ƒí—ˆë¸Œ ì´ìŠˆ ë³¸ë¬¸ì€ ê¸°ë³¸ HTML ë Œë” OK)
            }

            // 5) í…œí”Œë¦¿ ë°”ì¸ë”©
            let producedBody = '';
            if (hasTemplate) {
              let body = tpl
                .replaceAll('{{issue.key}}', key)
                .replaceAll('{{key}}', key)
                .replaceAll('{{issue.url}}', urlLink)
                .replaceAll('{{url}}', urlLink)
                .replaceAll('{{issue.summary}}', summary)
                .replaceAll('{{summary}}', summary)
                .replaceAll('{{description}}', has(description) ? description : '')
                .replaceAll('{{priority}}', has(priority) ? priority : '')
                .replaceAll('{{issue.duedate}}', duedate)
                .replaceAll('{{duedate}}', duedate)
                .replaceAll('{{checklist}}', has(checklistMD) ? checklistMD : '');

              if (has(checklistMD) && !tpl.includes('{{checklist}}')) {
                body += `\n\n---\n\n### âœ… To-Do CheckList\n${checklistMD}\n`;
              }
              producedBody = body.trim();
            } else {
              // í…œí”Œë¦¿ì´ ì—†ì„ ë•Œ ìµœì†Œ ì•ˆì „ ì¡°ë¦½ (fallback)
              const parts = [];
              if (has(description)) {
                parts.push('## ğŸ“„ ì´ìŠˆ ê°œìš” (Description)', description, ''); // HTML ê·¸ëŒ€ë¡œ
              }
              if (has(checklistMD)) {
                parts.push('---', '', '### âœ… To-Do CheckList', checklistMD, '');
              }
              if (has(priority)) {
                parts.push('---', '', '### ğŸ¯ ìš°ì„ ìˆœìœ„', `<ins>${priority}</ins>`, '');
              }
              if (has(duedate)) {
                parts.push('', '### ğŸ“… ê¸°í•œ', `*${duedate}*`, '');
              }
              if (has(key) || has(urlLink)) {
                const link = has(urlLink) ? `[**${key}**](${urlLink})` : key;
                parts.push('', '### ğŸ”— Jira Link', link);
              }
              producedBody = parts.join('\n').trim();
            }

            // 6) ë³¸ë¬¸ êµì²´ ì¡°ê±´ (ê°’ì´ ì˜¤ê±°ë‚˜ í˜„ì¬ ë¹„ì–´ìˆì„ ë•Œë§Œ êµì²´)
            const shouldReplaceBody =
              has(description) || has(checklistMD) || has(priority) || has(duedate) || has(key) || has(urlLink) || !curBody;
            const nextBody = shouldReplaceBody ? (producedBody || curBody) : curBody;

            // 7) ì œëª©: ê°’ì´ ë¹„ë©´ ê¸°ì¡´ ìœ ì§€
            const nextTitle = (has(key) || has(summary))
              ? `[${nz(key, curTitle)}] ${nz(summary, curTitle)}`
              : curTitle;

            // 8) ë¼ë²¨ ê³„ì‚° (Story/Bug ê³ ì •, TaskëŠ” 3ì¢…ë§Œ; ë¹„ë©´ ê¸°ì¡´ ìœ ì§€)
            const allowed = new Set(['Feature','Refactor','Documentation','Story','Bug']);
            let computed = [];
            if (isStory) computed = ['Story'];
            else if (isBug) computed = ['Bug'];
            else {
              let incoming = [];
              if (Array.isArray(p.labels)) incoming = p.labels;
              else if (typeof p.labels === 'string') {
                try {
                  const parsed = JSON.parse(p.labels);
                  if (Array.isArray(parsed)) incoming = parsed;
                  else incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                } catch {
                  incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                }
              }
              const toTitle = s => s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s;
              computed = incoming.map(toTitle).filter(v => allowed.has(v) && v !== 'Story' && v !== 'Bug');
            }
            const setLabels = computed.length > 0; // ë¹„ë©´ ê¸°ì¡´ ë¼ë²¨ ìœ ì§€(ë¶ˆí•„ìš”í•œ 'Task' ìƒì„± ë°©ì§€)

            // 9) íŒ¨ì¹˜
            if (nextTitle !== curTitle || nextBody !== curBody) {
              await github.rest.issues.update({ owner, repo, issue_number, title: nextTitle, body: nextBody });
            }
            if (setLabels) {
              await github.rest.issues.setLabels({ owner, repo, issue_number, labels: computed });
            }

            core.info(`Patched #${issue_number} titleChanged=${nextTitle!==curTitle} bodyChanged=${nextBody!==curBody} labelsSet=${setLabels} kind=${kind} computed=${JSON.stringify(computed)}`);
