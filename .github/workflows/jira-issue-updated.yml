name: Update issue from Jira

on:
  repository_dispatch:
    types: [jira-issue-updated]

permissions:
  contents: read
  issues: write

jobs:
  update-issue:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # (선택) 들어온 payload를 한 번 확인하고 싶을 때 켠다
      - name: Debug payload (optional)
        run: echo "${{ toJson(github.event.client_payload) }}"

      - name: Render via template and safe patch (with Jira fetch fallback)
        uses: actions/github-script@v7
        env:
          # 🔐 레포/Org Secrets로 추가해둔 값 사용
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Node20은 global fetch가 존재. 없을 경우를 대비해 require fallback
            const fetch = global.fetch || ((...args) => import('node-fetch').then(({default: f}) => f(...args)));

            const p   = context.payload.client_payload || {};
            const esc = (s) => (s ?? '').toString();
            const nz  = (s, f='') => { const v = esc(s).trim(); return v ? v : f; };
            const has = (s) => !!esc(s).trim();

            // urlEncoded(%)이면 복원 (+ → 공백)
            const decodeMaybe = (s) => {
              const str = esc(s);
              try {
                const decoded = /%[0-9A-Fa-f]{2}/.test(str) ? decodeURIComponent(str) : str;
                return decoded.replace(/\+/g, ' ');
              } catch { return str; }
            };

            // ✅ Jira에서 rendered description(HTML) 보강
            async function fetchJiraDescriptionHTML(issueKey) {
              const base = (process.env.JIRA_BASE_URL || process.env.JIRA_BASE || '').replace(/\/+$/,'');
              if (!base || !issueKey) return '';
              const url = `${base}/rest/api/3/issue/${encodeURIComponent(issueKey)}?expand=renderedFields&fields=description`;
              const resp = await fetch(url, {
                headers: {
                  'Accept': 'application/json',
                  'Authorization': 'Basic ' + Buffer.from(`${process.env.JIRA_USER_EMAIL}:${process.env.JIRA_API_TOKEN}`).toString('base64')
                }
              });
              if (!resp.ok) {
                core.info(`Jira GET failed: ${resp.status} ${await resp.text()}`);
                return '';
              }
              const data = await resp.json();
              return (data.renderedFields && data.renderedFields.description) ? data.renderedFields.description : '';
            }

            // 🔧 체크리스트를 깃허브 체크박스로 정규화
            function normalizeChecklist(input) {
              const raw = decodeMaybe(input);
              if (!has(raw)) return '';
              const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              return lines.map(line => {
                // 이미 - [ ] 형태면 유지, 아니라면 변환
                if (/^- \[.\] /.test(line)) return line;
                // Jira의 [] 접두 등 다양한 패턴을 - [ ] 로 매핑
                if (/^\[\s?\]\s*/.test(line)) return line.replace(/^\[\s?\]\s*/, '- [ ] ');
                if (/^[\*\-]\s+/.test(line))   return line.replace(/^[\*\-]\s+/, '- [ ] ');
                return `- [ ] ${line}`;
              }).join('\n');
            }

            // 0) 필수값: GH 이슈번호
            const issue_number = Number(p.issue_number);
            if (!issue_number) { core.setFailed('Missing issue_number in payload'); return; }

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // 1) 현재 GH 이슈 읽기(빈값 덮어쓰기 방지)
            const cur = await github.rest.issues.get({ owner, repo, issue_number });
            const curTitle  = cur.data.title || '';
            const curBody   = cur.data.body  || '';
            const curLabels = (cur.data.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);

            // 2) kind 정규화 (한글/영문)
            const rawKind = esc(p.kind).toLowerCase();
            const isStory = /^(story|스토리)/.test(rawKind);
            const isBug   = /^(bug|버그)/.test(rawKind);
            const kind    = isStory ? 'story' : (isBug ? 'bug' : 'task');

            // 3) 템플릿 선택 (업데이트도 생성과 동일 템플릿 사용)
            const mapping = {
              story: '.github/ISSUE_TEMPLATE/automation-story.md',
              bug:   '.github/ISSUE_TEMPLATE/automation-bug.md',
              task:  '.github/ISSUE_TEMPLATE/automation-task.md'
            };
            const file = mapping[kind] || mapping.task;
            const templatePath = path.join(process.cwd(), file);
            const hasTemplate = fs.existsSync(templatePath);
            const tpl = hasTemplate ? fs.readFileSync(templatePath, 'utf8') : '';

            // 4) 값 준비 + Jira 보강
            const key         = esc(p.key);
            const urlLink     = esc(p.url);
            const summary     = esc(p.summary);
            let   description = esc(p.description);   // payload가 비면 Jira API로 보강
            const priority    = esc(p.priority);
            const duedate     = nz(p.duedate, '미정');
            const checklistMD = normalizeChecklist(p.checklist);

            if (!description.trim() && key) {
              const html = await fetchJiraDescriptionHTML(key);
              if (has(html)) description = html; // HTML 그대로 사용(깃허브 이슈 본문은 기본 HTML 렌더 OK)
            }

            // 5) 템플릿 바인딩
            let producedBody = '';
            if (hasTemplate) {
              let body = tpl
                .replaceAll('{{issue.key}}', key)
                .replaceAll('{{key}}', key)
                .replaceAll('{{issue.url}}', urlLink)
                .replaceAll('{{url}}', urlLink)
                .replaceAll('{{issue.summary}}', summary)
                .replaceAll('{{summary}}', summary)
                .replaceAll('{{description}}', has(description) ? description : '')
                .replaceAll('{{priority}}', has(priority) ? priority : '')
                .replaceAll('{{issue.duedate}}', duedate)
                .replaceAll('{{duedate}}', duedate)
                .replaceAll('{{checklist}}', has(checklistMD) ? checklistMD : '');

              if (has(checklistMD) && !tpl.includes('{{checklist}}')) {
                body += `\n\n---\n\n### ✅ To-Do CheckList\n${checklistMD}\n`;
              }
              producedBody = body.trim();
            } else {
              // 템플릿이 없을 때 최소 안전 조립 (fallback)
              const parts = [];
              if (has(description)) {
                parts.push('## 📄 이슈 개요 (Description)', description, ''); // HTML 그대로
              }
              if (has(checklistMD)) {
                parts.push('---', '', '### ✅ To-Do CheckList', checklistMD, '');
              }
              if (has(priority)) {
                parts.push('---', '', '### 🎯 우선순위', `<ins>${priority}</ins>`, '');
              }
              if (has(duedate)) {
                parts.push('', '### 📅 기한', `*${duedate}*`, '');
              }
              if (has(key) || has(urlLink)) {
                const link = has(urlLink) ? `[**${key}**](${urlLink})` : key;
                parts.push('', '### 🔗 Jira Link', link);
              }
              producedBody = parts.join('\n').trim();
            }

            // 6) 본문 교체 조건 (값이 오거나 현재 비어있을 때만 교체)
            const shouldReplaceBody =
              has(description) || has(checklistMD) || has(priority) || has(duedate) || has(key) || has(urlLink) || !curBody;
            const nextBody = shouldReplaceBody ? (producedBody || curBody) : curBody;

            // 7) 제목: 값이 비면 기존 유지
            const nextTitle = (has(key) || has(summary))
              ? `[${nz(key, curTitle)}] ${nz(summary, curTitle)}`
              : curTitle;

            // 8) 라벨 계산 (Story/Bug 고정, Task는 3종만; 비면 기존 유지)
            const allowed = new Set(['Feature','Refactor','Documentation','Story','Bug']);
            let computed = [];
            if (isStory) computed = ['Story'];
            else if (isBug) computed = ['Bug'];
            else {
              let incoming = [];
              if (Array.isArray(p.labels)) incoming = p.labels;
              else if (typeof p.labels === 'string') {
                try {
                  const parsed = JSON.parse(p.labels);
                  if (Array.isArray(parsed)) incoming = parsed;
                  else incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                } catch {
                  incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                }
              }
              const toTitle = s => s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s;
              computed = incoming.map(toTitle).filter(v => allowed.has(v) && v !== 'Story' && v !== 'Bug');
            }
            const setLabels = computed.length > 0; // 비면 기존 라벨 유지(불필요한 'Task' 생성 방지)

            // 9) 패치
            if (nextTitle !== curTitle || nextBody !== curBody) {
              await github.rest.issues.update({ owner, repo, issue_number, title: nextTitle, body: nextBody });
            }
            if (setLabels) {
              await github.rest.issues.setLabels({ owner, repo, issue_number, labels: computed });
            }

            core.info(`Patched #${issue_number} titleChanged=${nextTitle!==curTitle} bodyChanged=${nextBody!==curBody} labelsSet=${setLabels} kind=${kind} computed=${JSON.stringify(computed)}`);
