name: Update issue from Jira

on:
  repository_dispatch:
    types: [jira-issue-updated]

permissions:
  contents: read
  issues: write

jobs:
  update-issue:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Render via template and safe patch
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const p   = context.payload.client_payload || {};
            const esc = (s) => (s ?? '').toString();
            const nz  = (s, f='') => { const v = esc(s).trim(); return v ? v : f; };
            const has = (s) => !!esc(s).trim();

            // urlEncoded(%)ì´ë©´ ë³µì› (+ â†’ space ë³´ì •)
            const decodeMaybe = (s) => {
              const str = esc(s);
              try {
                let decoded = /%[0-9A-Fa-f]{2}/.test(str) ? decodeURIComponent(str) : str;
                decoded = decoded.replace(/\+/g, ' ');
                return decoded;
              } catch { return str; }
            };

            // âœ… ê¹ƒí—ˆë¸Œ ì²´í¬ë°•ìŠ¤ í¬ë§·ìœ¼ë¡œ ì •ê·œí™”
            const toCheckboxList = (text) => {
              const lines = esc(text).replace(/\r\n?/g, '\n').split('\n');
              const out = [];
              for (let raw of lines) {
                let line = raw.trim();
                if (!line) continue;

                // ì´ë¯¸ ì²´í¬ë°•ìŠ¤ë©´ ìœ ì§€
                if (/^- \[.\]/.test(line)) { out.push(line); continue; }

                // [] ë˜ëŠ” [ ] ë¡œ ì‹œì‘ â†’ ì²´í¬ë°•ìŠ¤ë¡œ
                if (/^\[\s?\]/.test(line)) {
                  out.push(`- [ ] ${line.replace(/^$begin:math:display$\\s?$end:math:display$\s*/, '')}`);
                  continue;
                }

                // ë¶ˆë¦¿/ë²ˆí˜¸/ì  ë“±ìœ¼ë¡œ ì‹œì‘ â†’ ì²´í¬ë°•ìŠ¤ë¡œ
                if (/^(?:[-*â€¢]\s+|\d+[.)]\s+)/.test(line)) {
                  out.push(`- [ ] ${line.replace(/^(?:[-*â€¢]\s+|\d+[.)]\s+)/, '')}`);
                  continue;
                }

                // ê·¸ ì™¸ ì„ì˜ í…ìŠ¤íŠ¸ë„ ì²´í¬ë°•ìŠ¤ë¡œ
                out.push(`- [ ] ${line}`);
              }
              return out.join('\n');
            };

            // 0) í•„ìˆ˜ê°’: ì´ìŠˆ ë²ˆí˜¸
            const issue_number = Number(p.issue_number);
            if (!issue_number) {
              core.setFailed('Missing issue_number in payload');
              return;
            }
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // 1) í˜„ì¬ GH ì´ìŠˆ ì½ê¸°(ë¹ˆê°’ ë®ì–´ì“°ê¸° ë°©ì§€ìš©)
            const cur = await github.rest.issues.get({ owner, repo, issue_number });
            const curTitle  = cur.data.title || '';
            const curBody   = cur.data.body  || '';
            const curLabels = (cur.data.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);

            // 2) kind ì •ê·œí™” (í•œê¸€/ì˜ë¬¸)
            const rawKind = esc(p.kind).toLowerCase();
            const isStory = /^(story|ìŠ¤í† ë¦¬)/.test(rawKind);
            const isBug   = /^(bug|ë²„ê·¸)/.test(rawKind);
            const kind    = isStory ? 'story' : (isBug ? 'bug' : 'task');

            // 3) í…œí”Œë¦¿ ì„ íƒ (ì—…ë°ì´íŠ¸ë„ ìƒì„±ê³¼ ë™ì¼ í…œí”Œë¦¿ ì‚¬ìš©)
            const mapping = {
              story: '.github/ISSUE_TEMPLATE/automation-story.md',
              bug:   '.github/ISSUE_TEMPLATE/automation-bug.md',
              task:  '.github/ISSUE_TEMPLATE/automation-task.md'
            };
            const file = mapping[kind] || mapping.task;
            const templatePath = path.join(process.cwd(), file);
            const hasTemplate = fs.existsSync(templatePath);
            const tpl = hasTemplate ? fs.readFileSync(templatePath, 'utf8') : '';

            // 4) ê°’ ì¤€ë¹„
            const key         = esc(p.key);
            const url         = esc(p.url);
            const summary     = esc(p.summary);
            const description = esc(p.description);          // Jiraì—ì„œ htmlEscape ì ìš©ë˜ì–´ ì˜´
            const priority    = esc(p.priority);
            const duedate     = nz(p.duedate, 'ë¯¸ì •');
            const checklistRaw= decodeMaybe(p.checklist);    // Paragraph(urlEncode) â†’ decode
            const checklist   = toCheckboxList(checklistRaw);

            // 5) í…œí”Œë¦¿ ë°”ì¸ë”©
            let producedBody = '';
            if (hasTemplate) {
              let body = tpl
                .replaceAll('{{issue.key}}', key)
                .replaceAll('{{key}}', key)
                .replaceAll('{{issue.url}}', url)
                .replaceAll('{{url}}', url)
                .replaceAll('{{issue.summary}}', summary)
                .replaceAll('{{summary}}', summary)
                .replaceAll('{{description}}', has(description) ? description : '')
                .replaceAll('{{priority}}', has(priority) ? priority : '')
                .replaceAll('{{issue.duedate}}', duedate)
                .replaceAll('{{duedate}}', duedate)
                .replaceAll('{{checklist}}', has(checklist) ? checklist : '');

              // í…œí”Œë¦¿ì— {{checklist}} ìë¦¬í‘œì‹œìê°€ ì—†ë‹¤ë©´ ì„¹ì…˜ ìë™ ì¶”ê°€
              if (has(checklist) && !tpl.includes('{{checklist}}')) {
                body += `\n\n---\n\n### âœ… To-Do CheckList\n${checklist}\n`;
              }
              producedBody = body.trim();
            } else {
              // í…œí”Œë¦¿ì´ ì—†ì„ ë•Œ ìµœì†Œ ì•ˆì „ ì¡°ë¦½ (fallback)
              const parts = [];
              if (has(description)) {
                parts.push('## ğŸ“„ ì´ìŠˆ ê°œìš” (Description)', `> ${description}`, '');
              }
              if (has(checklist)) {
                parts.push('---', '', '### âœ… To-Do CheckList', checklist, '');
              }
              if (has(priority)) {
                parts.push('---', '', '### ğŸ¯ ìš°ì„ ìˆœìœ„', `<ins>${priority}</ins>`, '');
              }
              if (has(duedate)) {
                parts.push('', '### ğŸ“… ê¸°í•œ', `*${duedate}*`, '');
              }
              if (has(key) || has(url)) {
                const link = has(url) ? `[**${key}**](${url})` : key;
                parts.push('', '### ğŸ”— Jira Link', link);
              }
              producedBody = parts.join('\n').trim();
            }

            // 6) ë³¸ë¬¸ ë®ì–´ì“°ê¸° ì¡°ê±´ ë³´ê°•
            const shouldReplaceBody =
              has(description) || has(checklist) || has(priority) || has(duedate) || has(key) || has(url) || !curBody;

            const nextBody = shouldReplaceBody ? (producedBody || curBody) : curBody;

            // 7) ì œëª©: ê°’ì´ ë¹„ë©´ ê¸°ì¡´ ìœ ì§€
            const nextTitle = (has(key) || has(summary))
              ? `[${nz(key, curTitle)}] ${nz(summary, curTitle)}`
              : curTitle;

            // 8) ë¼ë²¨ ê³„ì‚° (Story/Bug ê³ ì •, TaskëŠ” 3ì¢…ë§Œ; ë¹„ë©´ ê¸°ì¡´ ìœ ì§€)
            const allowed = new Set(['Feature','Refactor','Documentation','Story','Bug']);
            let computed = [];
            if (isStory) computed = ['Story'];
            else if (isBug) computed = ['Bug'];
            else {
              let incoming = [];
              if (Array.isArray(p.labels)) incoming = p.labels;
              else if (typeof p.labels === 'string') {
                try {
                  const parsed = JSON.parse(p.labels);
                  if (Array.isArray(parsed)) incoming = parsed;
                  else incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                } catch {
                  incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                }
              }
              const toTitle = s => s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s;
              computed = incoming.map(toTitle).filter(v => allowed.has(v) && v !== 'Story' && v !== 'Bug');
            }
            const setLabels = computed.length > 0; // ë¹„ë©´ ê¸°ì¡´ ë¼ë²¨ ìœ ì§€ (â€˜Taskâ€™ ìë™ ìƒì„± ë°©ì§€)

            // 9) íŒ¨ì¹˜
            if (nextTitle !== curTitle || nextBody !== curBody) {
              await github.rest.issues.update({ owner, repo, issue_number, title: nextTitle, body: nextBody });
            }
            if (setLabels) {
              await github.rest.issues.setLabels({ owner, repo, issue_number, labels: computed });
            }

            core.info(`Patched #${issue_number} titleChanged=${nextTitle!==curTitle} bodyChanged=${nextBody!==curBody} labelsSet=${setLabels} kind=${kind} computed=${JSON.stringify(computed)}`);
