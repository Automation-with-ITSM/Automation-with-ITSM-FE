name: Update issue from Jira

on:
  repository_dispatch:
    types: [jira-issue-updated]

permissions:
  contents: read
  issues: write

jobs:
  update-issue:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Render via template and safe patch
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const p   = context.payload.client_payload || {};
            const esc = (s) => (s ?? '').toString();
            const nz  = (s, f='') => { const v = esc(s).trim(); return v ? v : f; };
            const has = (s) => !!esc(s).trim();

            // urlEncoded(%)이면 복원 (+ → space 보정)
            const decodeMaybe = (s) => {
              const str = esc(s);
              try {
                let decoded = /%[0-9A-Fa-f]{2}/.test(str) ? decodeURIComponent(str) : str;
                decoded = decoded.replace(/\+/g, ' ');
                return decoded;
              } catch { return str; }
            };

            // ✅ 깃허브 체크박스 포맷으로 정규화
            const toCheckboxList = (text) => {
              const lines = esc(text).replace(/\r\n?/g, '\n').split('\n');
              const out = [];
              for (let raw of lines) {
                let line = raw.trim();
                if (!line) continue;

                // 이미 체크박스면 유지
                if (/^- \[.\]/.test(line)) { out.push(line); continue; }

                // [] 또는 [ ] 로 시작 → 체크박스로
                if (/^\[\s?\]/.test(line)) {
                  out.push(`- [ ] ${line.replace(/^$begin:math:display$\\s?$end:math:display$\s*/, '')}`);
                  continue;
                }

                // 불릿/번호/점 등으로 시작 → 체크박스로
                if (/^(?:[-*•]\s+|\d+[.)]\s+)/.test(line)) {
                  out.push(`- [ ] ${line.replace(/^(?:[-*•]\s+|\d+[.)]\s+)/, '')}`);
                  continue;
                }

                // 그 외 임의 텍스트도 체크박스로
                out.push(`- [ ] ${line}`);
              }
              return out.join('\n');
            };

            // 0) 필수값: 이슈 번호
            const issue_number = Number(p.issue_number);
            if (!issue_number) {
              core.setFailed('Missing issue_number in payload');
              return;
            }
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // 1) 현재 GH 이슈 읽기(빈값 덮어쓰기 방지용)
            const cur = await github.rest.issues.get({ owner, repo, issue_number });
            const curTitle  = cur.data.title || '';
            const curBody   = cur.data.body  || '';
            const curLabels = (cur.data.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);

            // 2) kind 정규화 (한글/영문)
            const rawKind = esc(p.kind).toLowerCase();
            const isStory = /^(story|스토리)/.test(rawKind);
            const isBug   = /^(bug|버그)/.test(rawKind);
            const kind    = isStory ? 'story' : (isBug ? 'bug' : 'task');

            // 3) 템플릿 선택 (업데이트도 생성과 동일 템플릿 사용)
            const mapping = {
              story: '.github/ISSUE_TEMPLATE/automation-story.md',
              bug:   '.github/ISSUE_TEMPLATE/automation-bug.md',
              task:  '.github/ISSUE_TEMPLATE/automation-task.md'
            };
            const file = mapping[kind] || mapping.task;
            const templatePath = path.join(process.cwd(), file);
            const hasTemplate = fs.existsSync(templatePath);
            const tpl = hasTemplate ? fs.readFileSync(templatePath, 'utf8') : '';

            // 4) 값 준비
            const key         = esc(p.key);
            const url         = esc(p.url);
            const summary     = esc(p.summary);
            const description = esc(p.description);          // Jira에서 htmlEscape 적용되어 옴
            const priority    = esc(p.priority);
            const duedate     = nz(p.duedate, '미정');
            const checklistRaw= decodeMaybe(p.checklist);    // Paragraph(urlEncode) → decode
            const checklist   = toCheckboxList(checklistRaw);

            // 5) 템플릿 바인딩
            let producedBody = '';
            if (hasTemplate) {
              let body = tpl
                .replaceAll('{{issue.key}}', key)
                .replaceAll('{{key}}', key)
                .replaceAll('{{issue.url}}', url)
                .replaceAll('{{url}}', url)
                .replaceAll('{{issue.summary}}', summary)
                .replaceAll('{{summary}}', summary)
                .replaceAll('{{description}}', has(description) ? description : '')
                .replaceAll('{{priority}}', has(priority) ? priority : '')
                .replaceAll('{{issue.duedate}}', duedate)
                .replaceAll('{{duedate}}', duedate)
                .replaceAll('{{checklist}}', has(checklist) ? checklist : '');

              // 템플릿에 {{checklist}} 자리표시자가 없다면 섹션 자동 추가
              if (has(checklist) && !tpl.includes('{{checklist}}')) {
                body += `\n\n---\n\n### ✅ To-Do CheckList\n${checklist}\n`;
              }
              producedBody = body.trim();
            } else {
              // 템플릿이 없을 때 최소 안전 조립 (fallback)
              const parts = [];
              if (has(description)) {
                parts.push('## 📄 이슈 개요 (Description)', `> ${description}`, '');
              }
              if (has(checklist)) {
                parts.push('---', '', '### ✅ To-Do CheckList', checklist, '');
              }
              if (has(priority)) {
                parts.push('---', '', '### 🎯 우선순위', `<ins>${priority}</ins>`, '');
              }
              if (has(duedate)) {
                parts.push('', '### 📅 기한', `*${duedate}*`, '');
              }
              if (has(key) || has(url)) {
                const link = has(url) ? `[**${key}**](${url})` : key;
                parts.push('', '### 🔗 Jira Link', link);
              }
              producedBody = parts.join('\n').trim();
            }

            // 6) 본문 덮어쓰기 조건 보강
            const shouldReplaceBody =
              has(description) || has(checklist) || has(priority) || has(duedate) || has(key) || has(url) || !curBody;

            const nextBody = shouldReplaceBody ? (producedBody || curBody) : curBody;

            // 7) 제목: 값이 비면 기존 유지
            const nextTitle = (has(key) || has(summary))
              ? `[${nz(key, curTitle)}] ${nz(summary, curTitle)}`
              : curTitle;

            // 8) 라벨 계산 (Story/Bug 고정, Task는 3종만; 비면 기존 유지)
            const allowed = new Set(['Feature','Refactor','Documentation','Story','Bug']);
            let computed = [];
            if (isStory) computed = ['Story'];
            else if (isBug) computed = ['Bug'];
            else {
              let incoming = [];
              if (Array.isArray(p.labels)) incoming = p.labels;
              else if (typeof p.labels === 'string') {
                try {
                  const parsed = JSON.parse(p.labels);
                  if (Array.isArray(parsed)) incoming = parsed;
                  else incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                } catch {
                  incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                }
              }
              const toTitle = s => s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s;
              computed = incoming.map(toTitle).filter(v => allowed.has(v) && v !== 'Story' && v !== 'Bug');
            }
            const setLabels = computed.length > 0; // 비면 기존 라벨 유지 (‘Task’ 자동 생성 방지)

            // 9) 패치
            if (nextTitle !== curTitle || nextBody !== curBody) {
              await github.rest.issues.update({ owner, repo, issue_number, title: nextTitle, body: nextBody });
            }
            if (setLabels) {
              await github.rest.issues.setLabels({ owner, repo, issue_number, labels: computed });
            }

            core.info(`Patched #${issue_number} titleChanged=${nextTitle!==curTitle} bodyChanged=${nextBody!==curBody} labelsSet=${setLabels} kind=${kind} computed=${JSON.stringify(computed)}`);
